#! /usr/bin/env python
import pdb
import optparse
import os
import sys
import re
import signal
import time
import urllib
import urllib2
import resource
import subprocess


usageStr = '''
usage:
    a4_tools cmd [options]
commands:
    start                      start a4
    stop                       stop a4
    reload                     reload a4 graceful
    update                     update data graceful
    stopnode[sn]               stop [upstream|group|peer] node
    recovernode[rn]            recover [upstream|group|peer] node
    getnodestatus[gn]          get [upstream|group|peer] node status
options:
   -h help, --help=help
'''

class A4Config:
    def __init__(self, fileName):
        self.fileName = fileName
        self.listenSpec = None
        self.controlCmdLocation = None
        self.workdir = None
        self.isHttps = False

    def hasVariable(self, content):
        pos = content.find('$(')
        if pos == -1:
            return False
        if content.find(')', pos + 2) == -1:
            return False
        return True

    def parse(self):
        if not self.fileName:
            return False
        content = ''
        try:
            content =  open(self.fileName).read()
        except Exception, err:
            print >> sys.stderr, "read [%s] failed [%s]" % (self.fileName, str(err))
            return False

        value = self.parseTag(content, 'control_cmd_location')
        if value is None or self.hasVariable(value):
            print >> sys.stderr, "get [control_cmd_location] from [%s] failed" % (self.fileName)
            return False
        self.controlCmdLocation = value

        value = self.parseTag(content, 'workdir')
        if value is None or self.hasVariable(value):
            print >> sys.stderr, "get [workdir] from [%s] failed" % (self.fileName)
            return False
        self.workdir = value

        value = self.parseTag(content, 'is_server_secure')
        if value is not None:
            if self.hasVariable(value):
                print >> sys.stderr, "parse [is_server_secure] from [%s] failed, has template variable" % (self.fileName)
                return False
            if cmp(value, 'on') == 0:
                self.isHttps = True
        return True

    def parseTag(self, content, tag):
        startTag = '<' + tag + '>'
        startPos = content.find(startTag)
        if startPos == -1:
            return None
        startPos += len(startTag)
        endTag = '</' + tag + '>'
        endPos = content.find(endTag, startPos)
        if endPos == -1:
            return None
        return content[startPos:endPos].strip()

class A4Template:
    def __init__(self, fileName):
        self.fileName = fileName
        self.listenSpec = None

    def getListenSpec(self):
        if self.listenSpec is None:
            if not self.parse():
                return None
        return self.listenSpec
    def loadTemplate(self):
        kvMap = {}
        with open(self.fileName) as f:
            while True:
                line = f.readline()
                if not line:
                    break
                line = line.strip()
                kv = line.split('=')
                if len(kv) != 2:
                    continue
                k = kv[0].strip()
                v = kv[1].strip()
                kvMap[k] = v
        return kvMap
    def parse(self):
        kvMap = self.loadTemplate()
        if not kvMap.has_key("port"):
            print >> sys.stderr, "get [port] from [%s] failed" % (self.fileName)
            return False
        self.listenSpec = "0.0.0.0:"+kvMap["port"]
        return True
class CommandBase:
    def __init__(self):
        self.options = None
        self.args = None
        self.parser = optparse.OptionParser()
        self.config = None
        self.template = None
    def addOptions(self):
        pass

    def checkArgs(self):
        pass

    def validateConfig(self):
        if self.options.configFile is None:
            return False
        config = A4Config(self.options.configFile)
        if not config.parse():
            return False
        self.config = config
        if self.options.templateFile:
            template = A4Template(self.options.templateFile)
            if not template.parse():
                return False
            self.template = template        
        return True

    def parseOptions(self, argv):
        self.addOptions()
        (self.options, self.args) = self.parser.parse_args(argv)
        if not self.checkArgs():
            print >> sys.stderr, self.getUsage()
            return False
        return True

    def getListenSpec(self):
        return self.template.listenSpec

    def getControlCmdLocation(self):
        return self.config.controlCmdLocation

    def getWorkdir(self):
        return self.config.workdir

    def getPidFile(self):
        pidFile = None
        try:
            workdir = self.getWorkdir()
            if workdir is None:
                return None
            pidFile = os.path.join(workdir, 'master.pid')
            if not os.path.isfile(pidFile):
                return None
        except:
            return None
        return pidFile
  
    def getMasterPid(self):
        pidFile = self.getPidFile()
        if pidFile is None:
            return None
        try:
            pid = open(pidFile).readline()
        except:
            print >> sys.stderr, "read pid file [%s] failed" % pidFile
            return None

        if not pid:
            print >> sys.stderr, "master.pid is empty!"
            return None
        try:
            pidNumber = int(pid)
        except ValueError:
            print >> sys.stderr, "the content of master.pid [%s] is invalid!" % pid
            return None
        return pidNumber

    def getChildPidList(self, pid):
        pidList = []
        cmd = 'ps -efwww | grep %s | grep -v grep' % pid
        (stdout, stderr) = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                                                stderr=subprocess.PIPE).communicate()
        stdout = stdout.strip()
        if stdout == "":
            return pidList
        lines = stdout.split('\n')
        for line in lines:
            elems = line.split()
            if str(pid) == elems[2]:
                pidList.append(elems[1])
        return pidList

    def sendGetRequest(self, args):
        spec = self.getListenSpec()
        if spec is None:
            print >> sys.stderr, "spec is None!"
            return None
        location = self.getControlCmdLocation();
        if location is None:
            return None
        if self.config.isHttps:
            url = 'https://' + spec + location + '?' + args
        else:
            url = 'http://' + spec + location + '?' + args
        try:
            req = urllib2.Request(url)
            response = urllib2.urlopen(req)
            content = response.read()
        except Exception, e:
            print >> sys.stderr, "request http failed [%s]" % str(e)
            return None
        return content

    def getUsage(self):
        return ''

class StartCommand(CommandBase):
    startUsage = '''usage:
    a4_tool start -c config-file -l log-file 
options:
      -c config-file
      -l a4-log-file
      -t template-file
      -p preload-file
      -w wait-timeout
example:
      a4_tool start -c conf/a4_config.xml -l conf/a4_logger.conf -p /usr/lib64/libtcmalloc.so.0  [-w timeout]
'''
    def addOptions(self):
        self.parser.add_option('-c', None, action='store', dest='configFile', help='a4 config file')
        self.parser.add_option('-l', None, action='store',dest='logFile', help='a4 log config file')
        self.parser.add_option('-t', None, action='store',dest='templateFile', help='a4 template file')
        self.parser.add_option('-p', None, action='append', default=[], dest='preload', help='preload file')
        self.parser.add_option('-w', None, action='store', dest='waitTimeout', help='waitTimeout, 0 is blocking')

    def checkArgs(self):
        if not self.options.configFile or not self.options.logFile:
            return False
        for preload in self.options.preload:
            if not os.path.exists(preload):
                print >> sys.stderr, "[%s] not existed" % (preload)
                return False
        return True

    def checkService(self):
        args = urllib.urlencode({'type':'check'})
        resp = self.sendGetRequest(args)
        if resp is None:
            return False
        return True

    def execute(self, argv):
        if not self.parseOptions(argv) or not self.validateConfig():
            return False
        
        if not self.getPidFile() is None:
            print >> sys.stderr, "start a4 failed [master.pid has been existed]"
            return False

        #set LD_PRELOAD
        bakPath = None
        if os.environ.has_key('LD_PRELOAD'):
            bakPath = os.environ['LD_PRELOAD']
        path = ':'.join(self.options.preload)
        if bakPath:
            path = path + ':' + bakPath
        os.environ['LD_PRELOAD'] = path

        #set LD_LIBRARY_PATH Todo: add more dependency path
        realPath = os.path.dirname(os.path.realpath(__file__))
        libPath = '%s/../lib64:%s/../usr/lib64:%s/../lib:%s/../usr/lib:%s/../usr/local/lib64:%s/../usr/local/lib:/usr/local/lib/:/usr/local/lib64' % \
            (realPath, realPath, realPath, realPath, realPath, realPath)
        if os.environ.has_key('LD_LIBRARY_PATH'):
            ldLibPath = os.environ['LD_LIBRARY_PATH']
        else:
            ldLibPath = ''
        os.environ['LD_LIBRARY_PATH'] = libPath + ':' + ldLibPath

        #set core limit
        try:
            resource.setrlimit(resource.RLIMIT_CORE, (-1, -1))
        except ValueError:
            print >> sys.stderr, 'setrlimit core failed'
        cmd = '%s/a4 -c %s -l %s' % \
            (realPath, self.options.configFile, self.options.logFile)
        if self.options.templateFile:
            cmd += ' -t ' + self.options.templateFile

        #start a4
        os.system(cmd)
        print >> sys.stderr, "a4 is starting ..."

        #check a4 status
        loopCount = 120
        if self.options.waitTimeout:
            loopCount = int(self.options.waitTimeout)
        tickCount = 0    
        while True:
            tickCount += 1
            if loopCount <= 0:
                pass
            elif loopCount > 0 and tickCount > loopCount:
                break
            time.sleep(1)
            if self.getMasterPid() is None:
                print >> sys.stderr, "start a4 failed [start failed]"
                return False
            if self.checkService():
                print >> sys.stderr,  "start a4 success"
                return True

        print >> sys.stderr, "start a4 failed [start a4 timeout]"
        return False

    def getUsage(self):
        return self.startUsage

class StopCommand(CommandBase):
    stopUsage = '''usage:
    a4_tool stop -c config-file 
options:
      -c config-file
      -w wait-timeout
example:
      a4_tool stop -c conf/a4_config.xml [-w tiemout]
'''
    def addOptions(self):
        self.parser.add_option('-c', None, action='store', dest='configFile', help='a4 config file')
        self.parser.add_option('-w', None, action='store', dest='waitTimeout', help='waitTimeout, 0 is blocking')
        self.parser.add_option('-t', None, action='store', dest='templateFile', help='a4 template file')
    def checkArgs(self):
        if not self.options.configFile:
            return False
        return True

    def execute(self, argv):
        if not self.parseOptions(argv) or not self.validateConfig():
            return False
        masterPid = self.getMasterPid()
        if masterPid is None:
            print >> sys.stderr, "stop a4 failed [a4 not alive]"
            return False
        os.kill(masterPid, signal.SIGQUIT)
        print >> sys.stderr, "a4 is stopping..."
        loopCount = 60
        if self.options.waitTimeout:
            loopCount = int(self.options.waitTimeout)
        tickCount = 0    
        while True:
            tickCount += 1
            if loopCount <= 0:
                pass
            elif loopCount > 0 and tickCount > loopCount:
                break
            newMasterPid = self.getMasterPid()
            if newMasterPid is None or newMasterPid != masterPid:
                print >> sys.stderr, "stop a4 success"
                return True
            time.sleep(1)

        cmd = 'ps -efwww | grep %s | grep -v grep' % masterPid
        (stdout, stderr) = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE,
                                                stderr=subprocess.PIPE).communicate()
        stdout = stdout.strip()
        if stdout == "":
            print >> sys.stderr, "a4 has been stoped, but you need delete the master.pid manually!"
            return False
        else:
            if newMasterPid == masterPid:
                print >> sys.stderr, "stop a4 failed [check stop timeout]"
            else:   
                print >> sys.stderr, "stop a4 failed [permission denied]"
            return False
    
    def getUsage(self):
        return self.stopUsage

class ReloadCommand(CommandBase):
    reloadUsage = '''usage:
    a4_tool reload -c config-file 
options:
      -c config-file
      -w wait-timeout
example:
      a4_tool reload -c conf/a4_config.xml [-w timeout]
'''
    def addOptions(self):
        self.parser.add_option('-c', None, action='store', dest='configFile', help='a4 config file')
        self.parser.add_option('-w', None, action='store', dest='waitTimeout', help='waitTimeout, 0 is blocking')
        self.parser.add_option('-t', None, action='store', dest='templateFile', help='a4 template file')

    def checkArgs(self):
        if not self.options.configFile:
            return False
        return True

    def execute(self, argv):
        if not self.parseOptions(argv) or not self.validateConfig():
            return False
        masterId = self.getMasterPid()
        if masterId is None:
            print >> sys.stderr, "reload a4 failed [a4 not alive]"
            return False
        childrenPids = self.getChildPidList(masterId)
        if childrenPids is None or len(childrenPids) == 0:
            print >> sys.stderr, "reload a4 failed [no a4 worker process alive]"
            return False
        if len(childrenPids) > 1:
            print >> sys.stderr, "reload a4 failed [a4 is reloading]"
            return False
        oldWorkerPid = childrenPids[0]
        os.kill(masterId, signal.SIGHUP)
        print >> sys.stderr, "a4 is reloading ..."
        time.sleep(1)
        loopCount = 100
        if self.options.waitTimeout:
            loopCount = int(self.options.waitTimeout)
        tickCount = 0    
        while True:
            tickCount += 1
            if loopCount <= 0:
                pass
            elif loopCount > 0 and tickCount > loopCount:
                break
            childrenPids = self.getChildPidList(masterId)
            if len(childrenPids) == 1:
                if oldWorkerPid not in childrenPids:
                    print >> sys.stderr, "reload a4 success"
                    return True
                else:
                    print >> sys.stderr, "reload a4 failed [new process start failed]"
                    return False
            else:
                time.sleep(1)
        print >> sys.stderr, 'reload a4 failed [reload timeout]'
        return False

    def getUsage(self):
        return self.reloadUsage

class UpdateCommand(CommandBase):
    updateUsage = '''usage:
    a4_tool update -c config-file -d data-name
options:
      -c config-file
      -d data-name
example:
      a4_tool update -c conf/a4_config.xml -d makeup
'''
    def addOptions(self):
        self.parser.add_option('-c', None, action='store', dest='configFile', help='a4 config file')
        self.parser.add_option('-d', None, action='store', dest='dataName', help='data name in a4 config')
        self.parser.add_option('-t', None, action='store', dest='templateFile', help='a4 template file')
    def checkArgs(self):
        if not self.options.configFile:
            return False
        if not self.options.dataName:
            return False
        return True

    def execute(self, argv):
        if not self.parseOptions(argv) or not self.validateConfig():
            return False
        args = urllib.urlencode({'type':'data', 'op':'update', 'name':self.options.dataName})
        resp = self.sendGetRequest(args)
        if resp is None:
            print >> sys.stderr, "update [%s] failed" % self.options.dataName
            return False
        print >> sys.stderr, "update [%s] success" % self.options.dataName
        return True
    
    def getUsage(self):
        return self.updateUsage

class NodeCommand(CommandBase):
    nodeUsage = '''usage:
    a4_tool [stopnode|recovernode|getnodestatus] -c config-file -u upstream-name -g group-name -p peer-id
options:
      -c config-file
      -u upstream-name
      -g group-name
      -p peer-id
example:
      a4_tool stopnode -c conf/a4_config.xml -u qp -g group1
'''
    def addOptions(self):
        self.parser.add_option('-c', None, action='store', dest='configFile', help='a4 config file')
        self.parser.add_option('-u', None, action='store', dest='upstreamName', help='upstream node name in a4 config')
        self.parser.add_option('-g', None, action='store', dest='groupName', help='group node name in a4 config')
        self.parser.add_option('-p', None, action='store', dest='peerId', help='peer node id in a4 config')
        self.parser.add_option('-t', None, action='store', dest='templateFile', help='a4 template file')
    def checkArgs(self):
        if not self.options.configFile:
            return False
        if not self.options.upstreamName:
            return False
        return True

    def getUsage(self):
        return self.nodeUsage

class StopNodeCommand(NodeCommand):
    def execute(self, argv):
        if not self.parseOptions(argv) or not self.validateConfig():
            return False
        if self.options.groupName is None:
            args = urllib.urlencode({'type':'node', 'op':'stopnode', 'upstream':self.options.upstreamName})
        elif self.options.peerId is None:
            args = urllib.urlencode({'type':'node', 'op':'stopnode', 'upstream':self.options.upstreamName, 'group':self.options.groupName})
        else:
            args = urllib.urlencode({'type':'node', 'op':'stopnode', 'upstream':self.options.upstreamName, 'group':self.options.groupName, 'peer':self.options.peerId})
        resp = self.sendGetRequest(args)
        if resp is None:
            print >> sys.stderr, "stop node failed"
            return False
        print >> sys.stderr, "stop node success"
        return True        

class RecoverNodeCommand(NodeCommand):
    def execute(self, argv):
        if not self.parseOptions(argv) or not self.validateConfig():
            return False
        if self.options.groupName is None:
            args = urllib.urlencode({'type':'node', 'op':'recovernode', 'upstream':self.options.upstreamName})
        elif self.options.peerId is None:
            args = urllib.urlencode({'type':'node', 'op':'recovernode', 'upstream':self.options.upstreamName, 'group':self.options.groupName})
        else:
            args = urllib.urlencode({'type':'node', 'op':'recovernode', 'upstream':self.options.upstreamName, 'group':self.options.groupName, 'peer':self.options.peerId})
        resp = self.sendGetRequest(args)
        if resp is None:
            print >> sys.stderr, "recover node failed"
            return False
        print >> sys.stderr, "recover node success"
        return True        

class GetNodeCommand(NodeCommand):
    def execute(self, argv):
        if not self.parseOptions(argv) or not self.validateConfig():
            return False
        args = urllib.urlencode({'type':'node', 'op':'getnodestatus', 'upstream':self.options.upstreamName})
        resp = self.sendGetRequest(args)
        if resp is None:
            print >> sys.stderr, "get node status failed"
            return False
        print >> sys.stderr, resp
        return True        

class A4Tool:
    def __init__(self):
        pass

    def printUsage(self):
        print >> sys.stderr, usageStr
    
    def execute(self, argv):
        if len(argv) < 2:
            self.printUsage()
            return False
        cmdStr = argv[1]
        if cmdStr == 'start':
            self.cmd = StartCommand()
        elif cmdStr == 'stop':
            self.cmd = StopCommand()
        elif cmdStr == 'reload':
            self.cmd = ReloadCommand()
        elif cmdStr == 'update':
            self.cmd = UpdateCommand()
        elif cmdStr in ['stopnode', 'sn']:
            self.cmd = StopNodeCommand()
        elif cmdStr in ['recovernode', 'rn']:
            self.cmd = RecoverNodeCommand()
        elif cmdStr in ['getnodestatus', 'gn']:
            self.cmd = GetNodeCommand()
        else:
            print >> sys.stderr, "invalid subcommand [%s]" % cmdStr
            self.printUsage()
            return False
        return self.cmd.execute(sys.argv[2:])
    
if __name__ == '__main__':
    filePath = './a4_conf.xml'
    tool = A4Tool()
    ret = tool.execute(sys.argv)
    if ret:
        sys.exit(0)
    else:
        sys.exit(1)


